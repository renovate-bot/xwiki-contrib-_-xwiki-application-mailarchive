<?xml version="1.0" encoding="UTF-8"?>

<xwikidoc version="1.1">
  <web>MailArchiveCode</web>
  <name>CreateWikiUsersFromMails</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1394137074000</creationDate>
  <parent>MailArchiveCode.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <customClass/>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1393179257000</date>
  <contentUpdateDate>1393179257000</contentUpdateDate>
  <version>1.1</version>
  <title>Parse users defined in loaded mails and creates corresponding profiles in xwiki if not already existing</title>
  <defaultTemplate/>
  <validationScript/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.0</syntaxId>
  <hidden/>
  <content>{{include document="WikiDev.LDAPUser" context="current"/}}

{{groovy}}
   def maxNb = 50

   def confirm = (request.getParameter("submit") != null || request.getParameter("submit") == "submit")
   xcontext.put('confirm', confirm)

   // Manage pagination
   def start = 0
   try {
     start = util.parseInt(request.getParameter("start"))
   } catch (NumberFormatException nfE) {
     start = 0
   }
   if (start == null || start == "" || start == "null") {
     start = 0
   }
   def nb = maxNb
   try {
     nb = util.parseInt(request.getParameter("nb"))
   } catch (NumberFormatException nfE) {
     nb = maxNb
   }
   if (nb == null || nb == "" || nb == "null" || nb == 0) {
     nb = maxNb
   }
   def next = (request.getParameter("next") != null &amp;&amp; request.getParameter("next") != "null" &amp;&amp; request.getParameter("next") != "")
   def previous = (request.getParameter("previous") != null &amp;&amp; request.getParameter("previous") != "null" &amp;&amp; request.getParameter("previous") != "")

   if (next) {
     start = start + nb     
   }
   if (previous) {
     start = start - nb
   }
   xcontext.put('start',start)
   xcontext.put('nb',nb)

{{/groovy}}

{{velocity}}
{{html}}
Use this page to create wiki users profiles from mailing-list posters when they do not already exist.
Note : creations can be done only for 30 users at a time due to performances limits.
Lines in &lt;span style="color:green"&gt;green&lt;/span&gt; will lead to users creations, lines in &lt;span style="color:red"&gt;red&lt;/span&gt; relate to users not found even from LDAP.
Lines in &lt;span style="color:blue"&gt;blue&lt;/span&gt; are actions that will be performed if you click on submit button below.

&lt;form class="xform" name="form" id="form"&gt;
  &lt;span class="buttonwrapper"&gt;
    &lt;input class="button" type="submit" value="Refresh" name="refresh"/&gt;
    &lt;input class="button" type="submit" value="Create Users" name="submit"/&gt;
     #if ($xcontext.get('start') != 0)
       &lt;input class="button" type="submit" value="Show Previous 10" name="previous"/&gt;
     #end
    &lt;input class="button" type="submit" value="Show Next 10" name="next"/&gt;
    &lt;input type="hidden" name="start" value="$xcontext.get('start')"/&gt;
    &lt;input type="hidden" name="nb" value="$xcontext.get('nb')"/&gt;
  &lt;/span&gt;
&lt;/form&gt;
{{/html}}
{{/velocity}}

{{groovy}}
import com.xpn.xwiki.doc.*;
import com.xpn.xwiki.*;
import com.novell.ldap.LDAPAttribute;
import com.novell.ldap.LDAPAttributeSet;
import com.novell.ldap.LDAPConnection;
import com.novell.ldap.LDAPEntry;
import com.novell.ldap.LDAPException;
import com.novell.ldap.LDAPJSSESecureSocketFactory;
import com.novell.ldap.LDAPSearchConstraints;
import com.novell.ldap.LDAPSearchResults;
import com.novell.ldap.LDAPSocketFactory;
import com.xpn.xwiki.plugin.ldap.XWikiLDAPSearchAttribute;



import com.xpn.xwiki.util.Util
  import com.xpn.xwiki.plugin.ldap.XWikiLDAPUtils
  import com.xpn.xwiki.plugin.ldap.XWikiLDAPConnection
  import com.xpn.xwiki.plugin.ldap.XWikiLDAPUtils
  import com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl
  import com.xpn.xwiki.api.Object
  import java.text.MessageFormat

   /* If updateMode=true, will try not only to create not existing profiles, but to update existing ones */
   def updateMode = false
  

   def confirm = xcontext.get('confirm')
   def start = xcontext.get('start')
   def nb = xcontext.get('nb')

   println "Users ${start} - ${start+nb}"

   def auth = null

  // LDAP Connection
  ldapcntx = new XWikiLDAPConnection()
  //ldapcntx.open("", "", xwiki.context)
  ldapcntx.open("adam.gemalto.com", 389, "", "", "", false, xwiki.context)
  ldaputils = new XWikiLDAPUtils(ldapcntx)
  ldaputils.setBaseDN("dc=adamgis,dc=gemalto,dc=com")
  ldaputils.setUidAttributeName("userPrincipalName")

   def sql = "select count(distinct prop.value) from XWikiDocument as doc, BaseObject as obj, LargeStringProperty as prop where obj.className='MailArchiveCode.MailClass' and obj.name&lt;&gt;'MailArchiveCode.MailTemplate' and obj.id=prop.id and prop.name='from' and doc.fullName=obj.name and doc.author='XWiki.UserDoesNotExist'"
   def result = xwiki.search(sql,0,0)

   println "Total users : ${result}"


  println "|=Users"

   sql = "select distinct prop.value from XWikiDocument as doc, BaseObject as obj, LargeStringProperty as prop where obj.className='MailArchiveCode.MailClass' and obj.name&lt;&gt;'MailArchiveCode.MailTemplate' and obj.id=prop.id and prop.name='from' and doc.fullName=obj.name and doc.author='XWiki.UserDoesNotExist'"
   xwiki.search(sql, nb, start).each() { mail -&gt;
     println "|((("
     def create = false
     def update = false
     def profile = ""
     def parsedUser = parseUser(mail)
     if (parsedUser != null &amp;&amp; parsedUser.size() == 0 ) { parsedUser = null }
     if (parsedUser == null) {    
       if (!confirm) {
         println '(% style="color:black" %)'
         println "${parseId(mail)} : Not found in wiki profiles"
       }
     } else {
       println '(% style="color:black" %)'
       println "${parseId(mail)}: wiki profile already exists"
     }
     luser = LDAPUser.searchLDAPUserByMail(parseId(mail), ldaputils)
     if (luser == null) {
       def newmail = parseId(mail)
       if (newmail.toUpperCase().contains("-EXTERNAL")) {
         newmail = newmail.replaceAll(~/(.*)-EXTERNAL(.*)/, "\$1\$2")
       } else {
         newmail = newmail.replaceAll(~/(.*)@(.*)/, "\$1-external@\$2")
       }
       luser = LDAPUser.searchLDAPUserByMail(newmail, ldaputils)
     }
     if (luser != null) {        
        def foundWikiProfileWithSameUid = false
        if (parsedUser != null) {
          parsedUser.each() { user -&gt;
             if (luser.uid == user.replaceAll(~/XWiki[.](.*)/, "\$1")) {
                foundWikiProfileWithSameUid = true
             }
          }
          if (!foundWikiProfileWithSameUid) {
            if (!confirm) {
              println '(% style="color:red" %)'
              println "~ ~ ~ ~ ${luser.uid}: FOUND from LDAP with email but name different than wiki profile(s) ${parseUser(mail)} "
            }
            create = true
            profile = "XWiki.${luser.uid}"
            if (!confirm) {
              println '(% style="color:green" %)'
              println "~ ~ ~ ~ ${luser.uid}: profile ${profile} to create"
            }
          } else if (updateMode) {
            update = true
            profile = "XWiki.${luser.uid}"
            if (!confirm) {
              println '(% style="color:green" %)'
              println "~ ~ ~ ~ ${luser.uid}: FOUND from LDAP with email, profile ${profile} to update"
            }
          }
        } else {
          create = true
          profile = "XWiki.${luser.uid}"
          if (!confirm) {
            println '(% style="color:green" %)'
            println "~ ~ ~ ~ ${luser.uid}: FOUND from LDAP with email, profile ${profile} to create"
          }
        }
     } else {
        println '(% style="color:red" %)'
        println "~ ~ ~ ~ ${parseId(mail)}: NOT FOUND from LDAP"
     }

     if (create || update) {
        def userDoc = xwiki.getDocument(profile)
        try {
          //TODO : add all attributes that are mapped to xwiki profiles fields ...
          def attributes = ldaputils.searchUserAttributesByUid(userDoc.name, ldaputils.getAttributeNameTable(xcontext.getContext()))
          def DN = ldaputils.searchUserDNByUid(userDoc.name)
          if (create) {
            if (confirm) {
              ldaputils.createUserFromLDAP(userDoc.getDocument(), attributes, DN, userDoc.name, xcontext.getContext())
              println '(% style="color:green" %)'
              println "Wiki profile created for ${userDoc.name}"
            } else {
              println '(% style="color:blue" %)'
              println "~ ~ ~ ~ ~ ~ User to create from LDAP with id ${userDoc.name}, DN ~[${DN}~], attrs ~[${attributes}~] ..."
            }
          } else if (update &amp;&amp; updateMode) {
            if (confirm) {
              ldaputils.updateUserFromLDAP(userDoc.getDocument(), attributes, DN, userDoc.name, xcontext.getContext())
              println '(% style="color:green" %)'
              println "Wiki profile updated for ${userDoc.name}"
            } else {
              println '(% style="color:blue" %)'
              println "~ ~ ~ ~ ~ ~ User to update from LDAP with id ${userDoc.name}, DN ~[${DN}~], attrs ~[${attributes}~] ..."
            }
          }
        } catch (Throwable t) {
          println '(% style="color:red" %)'
          println "~ ~ ~ ~ Exception while creating profile : ${t.message} ${t}"
          t.printStackTrace()
        }
     }

     println ")))"
   }

  /*
     Parses a user string of the form "user &lt;usermail@com&gt;"
       - extract mail and if matched in xwiki user profiles, returns page(s) name(s) for this profile
       - returns null string if no match is found
  */
  String[] parseUser (user) {
    def start = user.indexOf('&lt;')
    def end = user.indexOf('&gt;')
    def mail = ""
    if (start!=-1 &amp;&amp; end != -1) {
      mail = user.substring(start+1, end).toLowerCase()
    }
    if (mail != "") {
      // to match "-external" emails and old mails with '@gemplus.com'...
      mail = mail.toLowerCase()
      mail = mail.replaceAll(~/^([^-]*)(?:-.*)?@.*[.]com$/, "\$1%@%.com")   
      // Try to find a wiki profile with this email as parameter.
      // TBD : do this in the loading phase, and only try to search db if it was not found ?
      def hql = "select obj.name from BaseObject as obj, StringProperty as prop where obj.className='XWiki.XWikiUsers' and obj.id=prop.id and prop.name='email' and LOWER(prop.value) like '" + mail + "'"

      def wikiuser = xwiki.search(hql)
      return wikiuser

    } else {

      return null;
    }
  }

  /* 
      Parses an ID-type mail header, and remove possible '&lt;' and '&gt;'.
      Note : this should already have been done during mails load phase.
  */
  String parseId(id) {
    def start = id.indexOf('&lt;')
    def end = id.indexOf('&gt;')
    if (start!=-1 &amp;&amp; end!=-1) {
      return id.substring(start+1, end)
    } else {
      return id
    }
  }

{{/groovy}}</content>
</xwikidoc>
