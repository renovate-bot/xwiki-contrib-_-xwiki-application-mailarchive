<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
<web>MailArchiveCode</web>
<name>BatchSetBodyAsText</name>
<language></language>
<defaultLanguage>en</defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>XWiki.jbousque</creator>
<author>XWiki.Admin</author>
<customClass></customClass>
<contentAuthor>XWiki.Admin</contentAuthor>
<creationDate>1321871478000</creationDate>
<date>1344762921000</date>
<contentUpdateDate>1344762921000</contentUpdateDate>
<version>1.1</version>
<title>Set mail bodies as text</title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment>Imported from XAR</comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<content>Helping tool to text bodies ("body") of Mails when missing (converted from html bodies ("bodyhtml") )

{{groovy}}
   def maxNb = 150

   def confirm = (request.getParameter("submit") != null || request.getParameter("submit") == "submit")
   xcontext.put('confirm', confirm)

   // Manage pagination
   def start = 0
   try {
     start = util.parseInt(request.getParameter("start"))
   } catch (NumberFormatException nfE) {
     start = 0
   }
   if (start == null || start == "" || start == "null") {
     start = 0
   }
   def nb = maxNb
   try {
     nb = util.parseInt(request.getParameter("nb"))
   } catch (NumberFormatException nfE) {
     nb = maxNb
   }
   if (nb == null || nb == "" || nb == "null" || nb == 0) {
     nb = maxNb
   }
   def next = (request.getParameter("next") != null &amp;&amp; request.getParameter("next") != "null" &amp;&amp; request.getParameter("next") != "")
   def previous = (request.getParameter("previous") != null &amp;&amp; request.getParameter("previous") != "null" &amp;&amp; request.getParameter("previous") != "")

   if (next) {
     start = start + nb     
   }
   if (previous) {
     start = start - nb
   }
   xcontext.put('start',start)
   xcontext.put('nb',nb)

{{/groovy}}

{{velocity}}
{{html}}
&lt;form class="xform" name="form" id="form"&gt;
  &lt;span class="buttonwrapper"&gt;
    &lt;input class="button" type="submit" value="Refresh" name="refresh"/&gt;
    &lt;input class="button" type="submit" value="Set Bodies" name="submit"/&gt;
     #if ($xcontext.get('start') != 0)
       &lt;input class="button" type="submit" value="Show Previous $xcontext.get('nb')" name="previous"/&gt;
     #end
    &lt;input class="button" type="submit" value="Show Next $xcontext.get('nb')" name="next"/&gt;&lt;br/&gt;
    &lt;input type="hidden" name="start" value="$xcontext.get('start')"/&gt;
    &lt;input type="hidden" name="nb" value="$xcontext.get('nb')"/&gt;
  &lt;/span&gt;
&lt;/form&gt;
{{/html}}
{{/velocity}}

{{groovy}}

import java.util.zip.GZIPInputStream

def confirm = xcontext.get('confirm')
def start = xcontext.get('start')
def nb = xcontext.get('nb')

def xwql = "select count(doc.fullName) from Document doc, doc.object(MailArchiveCode.MailClass) as mail where mail.body='' and doc.fullName&lt;&gt;'MailArchiveCode.MailClassTemplate'"

def nbMails = services.get("query").xwql(xwql).execute()

println "Total Mails : ${nbMails}"

println "Mails ${start} - ${start+nb}"

xwql = "select doc.fullName, mail.bodyhtml from Document doc, doc.object(MailArchiveCode.MailClass) as mail where mail.body='' and doc.fullName&lt;&gt;'MailArchiveCode.MailClassTemplate'"

def results = services.get("query").xwql(xwql).setOffset(start).setLimit(nb).execute()

results.each() { page -&gt;

try {

  def docName = page[0]
  def bodyhtml = page[1]

  print "* [[${docName}]] : "

  def converted = null

  // Convert HTML body to plain text
  def html = unzipstring (bodyhtml)
  html = html.replaceAll(~/[\s]{2,}/, "\n")
  def xdom = services.rendering.parse(html, "html/4.01")
  converted = services.rendering.render(xdom, "plain/1.0")
  if (converted == null || converted == "") {
    println " Conversion returned empty string "
  } else {
    converted = converted.replaceAll(~/[\s]{2,}/, "\n")
    def display = converted.replaceAll(~/[\s]/, " ")
    display = (display.length()&gt;100?display[0..99]:display)
    print "((( [${display}] )))"
    if (confirm) {
      def doc = xwiki.getDocument(docName)
      doc.use('MailArchiveCode.MailClass')
      doc.set('body', converted)
      doc.document.setCreator(doc.document.creator)
      doc.document.setAuthor(doc.document.author)
      doc.document.setContentAuthor(doc.document.contentAuthor)
      doc.document.setDate(doc.document.date)
      doc.document.setCreationDate(doc.document.creationDate)
      doc.document.setContentDirty(false)
      doc.document.setMetaDataDirty(false) 

      xwiki.getXWiki().saveDocument(doc.document, xcontext.context)
      println "Updated ${doc} body"
    }
  }

}catch (Exception e) {
  println "Exception ${e}"
}
println ""

}

def unzipstring(zippedstr) {
  def zis = new GZIPInputStream(new ByteArrayInputStream(hex2byte(zippedstr)))
  def html = ""
  if (zis != null) 
  {
    StringBuilder sb = new StringBuilder();
    String line; 
    try 
    {
      BufferedReader reader = new BufferedReader(new InputStreamReader(zis, "UTF-8"));
      while ((line = reader.readLine()) != null) 
      {
        sb.append(line).append("\n");
      }
    } finally 
    {
      zis.close();
    }
    html = sb.toString();
  }     
  return html
}

 private byte charToByte(char c){
        return (byte) "0123456789ABCDEF".indexOf(""+c);
    }


   /**
     * BD : Used to transfer hex string into byte array. two hex string combines one byte. So that means the length of hex string
     *      should be even. Or the null will be returned.
     * @param hexStr
     * @return
     */
    public byte[] hex2byte(String hexStr) {
        if(hexStr == null || hexStr.isEmpty() || (hexStr.length()%2&gt;1)) {
            return null;
        }
        String hexStrUp = hexStr.toUpperCase();
        int length = hexStrUp.length()/2;
        char[] hexChars = hexStrUp.toCharArray();
        byte[] resultByte = new byte[length];
        for(int i=0;i&lt;length;i++) {
            int pos = i*2;
            resultByte[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos+1]));            
        }
        return resultByte;
    }

{{/groovy}}

</content></xwikidoc>