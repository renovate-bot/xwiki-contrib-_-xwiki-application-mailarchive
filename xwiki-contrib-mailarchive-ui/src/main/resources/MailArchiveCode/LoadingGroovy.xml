<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
<web>MailArchiveCode</web>
<name>LoadingGroovy</name>
<language></language>
<defaultLanguage></defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>XWiki.Admin</creator>
<author>XWiki.Admin</author>
<customClass></customClass>
<contentAuthor>XWiki.Admin</contentAuthor>
<creationDate>1353417891000</creationDate>
<date>1353417891000</date>
<contentUpdateDate>1353417891000</contentUpdateDate>
<version>1.1</version>
<title>LoadingGroovy</title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment>Import</comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<object>
<class>
<name>XWiki.TagClass</name>
<customClass></customClass>
<customMapping></customMapping>
<defaultViewSheet></defaultViewSheet>
<defaultEditSheet></defaultEditSheet>
<defaultWeb></defaultWeb>
<nameField></nameField>
<validationScript></validationScript>
<tags>
<cache>0</cache>
<disabled>0</disabled>
<displayType>input</displayType>
<multiSelect>1</multiSelect>
<name>tags</name>
<number>1</number>
<prettyName>Tags</prettyName>
<relationalStorage>1</relationalStorage>
<separator>|</separator>
<separators>|,</separators>
<size>30</size>
<unmodifiable>0</unmodifiable>
<values></values>
<classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
</tags>
</class>
<name>MailArchiveCode.LoadingGroovy</name>
<number>0</number>
<className>XWiki.TagClass</className>
<guid>e7d2aeaa-4b9f-4c35-a4cf-333417dd87b7</guid>
<property>
<tags/>
</property>
</object>
<content>
// Java imports
import java.io.ByteArrayOutputStream
import java.io.*;
import java.text.*;
import java.util.zip.GZIPOutputStream;

// Import for mails
import java.util.*;
import javax.mail.*;
import javax.mail.Folder;
import javax.mail.search.*;
import javax.mail.internet.MimeUtility;
import javax.mail.internet.MimeMessage
import javax.mail.util.SharedByteArrayInputStream
import com.sun.mail.util.BASE64DecoderStream

// XWiki imports
import com.xpn.xwiki.doc.*;
import com.xpn.xwiki.*;
import com.xpn.xwiki.util.Util;

public class LoadMailArchiveGroovy {

    def context;
    def xwiki;
    def request;
    def services
    def protocol;
    def server;
    def user;
    def pass;
    def userwiki
    def defaultUser;

    def existingTopics = [:]
    def existingMessages = [:]
    def threadsMap = [:]
    def mailingListFolder
    def debug = null;
    def unknownUser = "XWiki.UserDoesNotExist"

    // This class is a singleton
    public LoadMailArchiveGroovy () {
        try {
            def now = new Date()
            def sdf = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss")
            def nowstr = sdf.format(now)
            this.debug = new File("mails-${nowstr}.log")
            this.debug.write("")
        } catch (Exception e) 
        {
            System.out.println("MailArchiveCode.LoadingGroovy:constructor - Could not initialize logs ${e}")
            e.printStackTrace()
            this.debug = null;
        }
    }

    public isInstalled() {
        return "yes";
    }

    public addDebug(message)  
    {
        if (this.debug != null )
        {
            this.debug.append(message + "\n");
        }
    }

    public getDebug() 
    {
        if (this.debug != null )
        {
            return this.debug.text;
        } else return ""
    }

    public void setContext(context, xwiki, request, services) {
        addDebug("setContext()")
        this.context = context
        this.xwiki = xwiki
        this.request = request
        this.services = services
    }

    public String getLoadingUser() {
        if (defaultUser==null || defaultUser=="")
        return "XWiki.MailArchiveAdmin";
        else
        return defaultUser;
    }

    public void setMailServerFromPage(page) {
        addDebug("setMailServerFromPage()")
        def settingsDoc = xwiki.getDocument(page)
        settingsDoc.use("MailArchiveCode.SettingsClass")
        this.protocol = settingsDoc.getValue("mailprotocol")
        this.server = settingsDoc.getValue("mailserver")
        this.user = settingsDoc.getValue("mailuser")
        def folder = settingsDoc.getValue("mailfolder")
        if (folder!=null &amp;&amp; folder!="") 
        {
            this.mailingListFolder = folder
        }
        this.pass = settingsDoc.getValue("mailpassword");
        this.defaultUser = settingsDoc.getValue("user");
    }

    public void setMailServer(protocol, server, user, pass) {
        addDebug("setMailServer()")
        this.protocol = protocol;
        this.server = server;
        this.user = user;
        this.pass = pass;
    }

    public int checkMails() {
        try {
            return xwiki.mail.checkMail(protocol, server, user, pass)
        } catch (Throwable e) {
            addDebug("Failed to connect to mail server " + e.class + " " + e.getMessage())
            return -1;
        }
    }

    public int checkMails(serverSettingsPage) {
      def nbMessages = -1
      def serverDoc = xwiki.getDocument(serverSettingsPage)
println(serverDoc)
      def serverObj = serverDoc.getObject('MailArchiveCode.ServerSettingsClass')
println(serverObj)
      def server = serverObj.get('hostname')
      def port = serverObj.get('port')
      def protocol = serverObj.get('protocol')
      def user = serverObj.get('user')
      def password = serverObj.getProperty('password').getValue()
      def folder = serverObj.get('folder')
println(serverSettingsPage)
      try {
        
 
        // Get a session.  Use a blank Properties object.
        def props = new Properties();
        // necessary to work with Gmail
        props.put("mail.imap.partialfetch", "false");
        props.put("mail.imaps.partialfetch", "false");
        props.put("mail.store.protocol", "imaps");

        def session = Session.getDefaultInstance(props, null);
        // Get a Store object
        def store = session.getStore(protocol);
  
        // Connect to the mail account
        store.connect(server, user, password) 
        def fldr
        // Specifically for GMAIL ...
        if (server.endsWith(".gmail.com")) {
          fldr = store.getDefaultFolder()
        }

        fldr = store.getFolder(folder)
        fldr.open(Folder.READ_ONLY)

        // Searches for mails not already read
        def searchterms = new FlagTerm(new Flags(Flags.Flag.SEEN), false) 
        def messages = fldr.search(searchterms)
        nbMessages = messages.size()        
        try {
          store.close()
        } catch(MessagingException e) {
          addDebug("checkMails : Could not close connection")
        }
     } catch(AuthenticationFailedException e) {
       e.printStackTrace()
       return -1
     } catch (FolderNotFoundException e) {
       e.printStackTrace()
       return -5
     } catch(MessagingException e) {
       e.printStackTrace()
       if (e.getCause() instanceof java.net.UnknownHostException) {
         return -6
       } else {
         return -2
       }
     } catch(IllegalStateException e) {
       return -3
     } catch(Throwable t) {
       t.printStackTrace()       
       return -4
     }
     addDebug("checkMails : ${nbMessages} to be read from $server / $port / $protocol / $user / $folder")
     return nbMessages;
    }

    /** 
     * Main entry point, load maximum nb number of emails.
     * @param nb max number of emails to load in a row
     * @param withDelete if true deletes mails that have been successfully processed, if false only set them as read.
     */
    public boolean loadMails(int nb, withDelete) {

        // Try to retrieve lock - we want only one instance at a time
        if (!lock()) 
        {
            return false;
        } 

        try 
        {
            def loadingUserDoc = xwiki.getDocument(getLoadingUser());
            if (loadingUserDoc.isNew() || !loadingUserDoc.getObject("XWiki.XWikiUsers")) 
            {
                addDebug("Default Loading user set in Settings does not exist. Cannot load emails")
                return false;
            }

            // Get a session.  Use a blank Properties object.
            def props = new Properties();
            // necessary to work with Gmail
            props.put("mail.imap.partialfetch", "false");
            props.put("mail.imaps.partialfetch", "false");
            def session = Session.getInstance(props);
            // Get a Store object
            def store = session.getStore(protocol);

            // Connect to the mail account
            store.connect(server, user, pass) 
            def fldr = store.getFolder(mailingListFolder)
            fldr.open(Folder.READ_WRITE)

            // Searches for mails not already read
            def searchterms = new FlagTerm(new Flags(Flags.Flag.SEEN), false) 
            def messages = fldr.search(searchterms)
            def nbMessages = messages.size()
            addDebug('Messages found : ' + nbMessages)

            if (nbMessages &gt; 0) {
                // Load existing topics
                def nbTopics = loadExistingTopics()
                addDebug("Number of existing TOPICS loaded from db : $nbTopics")

                // Load existing mail ids
                def nbMails = loadExistingMessages()
                addDebug("Number of existing EMAILS loaded from db : $nbMails")

                // Load mailing lists settings
                def nbThreads = loadThreadsMap(threadsMap)

                def currmsg = 1
                def nbLoaded = 0
                // Load each message. If needed delete them, and in any case set them as read - only if could be loaded
                for(mail in messages) 
                {
                    def result = true
                    try 
                    {
                        addDebug("Loading mail ${currmsg}")   
                        try 
                        {
                            result = loadMail(mail, true, false, null)
                        } catch (javax.mail.MessagingException me) 
                        {
                            addDebug("Could not load mail normally due to MessagingException, trying to clone original email")
                            // specific case of unloadable mail
                            ByteArrayOutputStream bos = new ByteArrayOutputStream();
                            mail.writeTo(bos);
                            bos.close();
                            SharedByteArrayInputStream bis = new SharedByteArrayInputStream(bos.toByteArray());
                            MimeMessage cmail = new MimeMessage(session, bis);
                            bis.close();

                            result = loadMail(cmail, true, false, null)
                        }

                        if (result[0]==true) 
                        {
                            nbLoaded ++
                            if (withDelete==true) 
                            {
                                mail.setFlag(Flags.Flag.DELETED, true);
                            }
                            mail.setFlag(Flags.Flag.SEEN, true);
                        }
                    } catch (Exception e) 
                    {
                        addDebug("Failed to load mail with exception " + e.class + " " + e.getMessage())
                        e.printStackTrace()
                        addDebugStackTrace(e)
                    }
                    currmsg ++
                } // for each message
                addDebug("Loaded ${nbLoaded} messages over ${nbMessages}")
                try {
                  // Update timeline info if needed
                  if (nbLoaded &gt; 0) {
                     //@TODO : check an option for time-line generation
                     addDebug("Refreshing time line information")
URL url = new URL(xwiki.getDocument("MailArchiveCode.TimeLineFeed").getExternalURL() + "?xpage=plain");
URLConnection uc = url .openConnection()
BufferedReader br = new BufferedReader(
new InputStreamReader(
uc.getInputStream()))
String inputLine=null

while ((inputLine = br.readLine()) != null)
addDebug("\t" + inputLine)
br.close()
                     //println """{{include document="MailArchiveCode.TimeLineFeed" context="new" /}}"""
                     //addDebug(xwiki.getDocument('{{include document="MailArchiveCode.TimeLineFeed" context="new" /}}').getRenderedContent())
                  }
                } catch (Throwable t) {
                  addDebug("Failed to update time-line feed with exception " + t.class + " " + t.getMessage())
                }
            } // if there are message

            if (withDelete) 
            {
                fldr.close(true);
            } else 
            {
                fldr.close(false);
            }  

            store.close();
            return true;

        } catch (Throwable e) 
        {
            addDebug("Failed to load emails with exception " + e.class+ " " + e.getMessage())
            addDebugStackTrace(e)
        } finally 
        { 
            // Release the lock in any case
            release()
            System.out.println(getDebug());
        }

        return false;
    }
 
    /**
      * loadExistingTopics
      * Loads existing topics information from database.
     */
    public int loadExistingTopics() 
    {
      def xwql = "select doc.fullName, topic.topicid, topic.subject from Document doc, doc.object(MailArchiveCode.MailTopicClass) as  topic where doc.fullName&lt;&gt;'MailArchiveCode.MailTopicClassTemplate'"
      def topics = services.get("query").xwql(xwql).execute()

      topics.each { topic -&gt;
        // map[topicid] = [fullName, subject]
        existingTopics[topic[1]] = [topic[0], topic[2]] 
     }
     return topics.size()
    }

    /**
      * loadExistingMessages
      * Loads existings mails information from database.
     */
    public int loadExistingMessages() 
    {
        try {
          def xwql = "select mail.messageid, mail.messagesubject, mail.topicid, doc.fullName from Document doc, doc.object(MailArchiveCode.MailClass) as  mail where doc.fullName&lt;&gt;'MailArchiveCode.MailClassTemplate'"
          def messages = services.get("query").xwql(xwql).execute()

          if(messages != null) {
            messages.each { msg -&gt;
              if (msg[0] != null &amp;&amp; msg[0] != "") {
                // map[messageid] = [subject, topicid, fullName]
                existingMessages[msg[0]] = [msg[1], msg[2], msg[3]]
              } else {
                addDebug("Incorrect message object found in db for ${msg[3]}")
              }
            }
            return messages.size()
          } else {
            return 0
          }

        } catch(Exception e) {

            addDebug("Failed to load existing messages ${e}")
            addDebugStackTrace(e)
            return 0
        }


    }

    // ****************** Loads the list of mailing-lists addresses to be parsed and set in loaded mails tags
    public int loadThreadsMap (map)
    {
        def sql = "select str1.value, str2.value, str3.value from BaseObject as obj, StringProperty as str1, StringProperty as str2, StringProperty as str3 where obj.className='MailArchiveCode.ListsSettingsClass' and obj.id=str1.id and str1.name='pattern' and obj.id=str2.id and str2.name='displayname' and obj.id=str3.id and str3.name='Tag'"
        def props = xwiki.search(sql)
        def nb = 0

        try {
            props.each() { prop -&gt;   
                if (prop[0] != null &amp;&amp; prop[0] != "")
                {
                    map[prop[0]] = [prop[1], prop[2]]
                    nb++
                }
            }
        } catch (Exception e) {
            addDebug("Failed to load tags settings with exception " + e.class+ " " + e.getMessage())
            e.printStackTrace()
        }
        return nb
    }

    /** 
     * loadMail
     * Loads a mail (IMAPMessage), create wiki objects(MailTopicClass and MailClass) if confirm-ed.
     * Do not create topic is isAttachedMail, in this case parentMail (wiki page fullname) should be provided.
     */
    def loadMail(mail, confirm, isAttachedMail, parentMail) {
        addDebug("Loading mail content into wiki objects")

        // set loading user for rights - loading user must have edit rights on MailArchive and MailArchiveCode spaces
        xwiki.context.setUser(getLoadingUser())
        addDebug("Loading user ${getLoadingUser()} set in context")

        def msgDoc = null
        def topicDoc = null

        // Retrieve information for mailing-list from headers
        /* RULES :
        - first message of topic : 1- "Thread-Topic" = "Subject"   OR  2- min(Date)  OR 3- not exist(In-Reply-To)
        - 1 : subject or topic can be null or '' ? --&gt; NO
        - 3 : seems to be the best
        - Topic Id = Thread-Index.substring(0,30)
        - Tree structure : 
        - find first message of topic = firstMsg
        - for each msg in (In-Reply-To(msg)=Message-ID(firstMsg)) order by Date(msg)
        - increase level
        - display msg
        - for each msg2 in (In-Reply-To(msg2)=Message-ID(msg))  --&gt; Recursivity
        - decrease level
         */
        def MailItem m = parseMail(mail)
        addDebug("PARSED ${m.toString()}")

        def dateFormatter = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss ZZZZZ", m.locale)


        // Create a new topic if needed
        def existingTopicId = ""
        // we don't create new topics for attached emails
        if (!isAttachedMail) {
            existingTopicId = existsTopic(m.topicId, m.topic, m.replyToId)
            if (existingTopicId == null)
            {
                addDebug("  did not find existing topic, creating a new one")
                if (existingTopics.containsKey(m.topicId)) {
                  addDebug("  new topic but topicId already loaded, with use messageId as new topicId")
                  m.topicId = m.messageId                 
                }
                existingTopicId = m.topicId
                topicDoc = createTopicPage(m, dateFormatter, confirm)

                addDebug("  loaded new topic ${topicDoc}")
            } else if (similarSubjects(m.topic, existingTopics[existingTopicId][1]))
            {
                addDebug("  topic already loaded $m.topicId : ${existingTopics[existingTopicId]}")
                topicDoc = updateTopicPage(m, existingTopicId, dateFormatter, confirm)
            } else {
                addDebug("  found existing topic but subjects are too different, using new messageid as topicid [${m.messageId}]")
                m.topicId = m.messageId
                m.replyToId = ""
                existingTopicId = existsTopic(m.topicId, m.topic, m.replyToId)
                addDebug("  creating new topic")
                topicDoc = createTopicPage(m, dateFormatter, confirm)
            }
        } // if not attached email

        // Create a new message if needed
        if (!existingMessages.containsKey(m.messageId))
        {
            addDebug("creating new message ${m.messageId} ...")     
            /* Note : use already existing topic id if any, instead of the one from the message, 
            to keep an easy to parse link between thread messages */
            if (existingTopicId == "") {
                existingTopicId = m.topicId
            }
            // Note : correction bug of messages linked to same topic but with different topicIds
            m.topicId = existingTopicId
            msgDoc = createMailPage (m, existingTopicId, isAttachedMail, parentMail, confirm)           
       
            return [true,(topicDoc!=null?topicDoc.fullName:topicDoc),(msgDoc!=null?msgDoc.fullName:msgDoc)];
        } else 
        {
            // message already loaded
            addDebug("Mail already loaded - checking for updates ...")

            def msg = existingMessages[m.messageId]
            addDebug("TopicId of existing message " + msg[1] + " and of topic " + existingTopicId + " are different ?" + (msg[1]!=existingTopicId))
            if (msg[1] != existingTopicId)
            {
                msgDoc = xwiki.getDocument(existingMessages[m.messageId][2])
                def msgObj = msgDoc.getObject("MailArchiveCode.MailClass")
                msgObj.set("topicid", existingTopicId)
                if (confirm) 
                {
                    addDebug("saving message ${m.subject}")
                    saveAsUser(msgDoc, null, getLoadingUser(), "Updated mail with existing topic id found")
                }
            }
          
            return [true,(topicDoc!=null?topicDoc.fullName:topicDoc),(msgDoc!=null?msgDoc.fullName:msgDoc)];
        }
    }

    /**
      * parseMail
      * Parse mail headers to create a MailItem. Decodes localization and date.
     */
    def parseMail(mail) {
   
        MailItem m = new MailItem()

        def topicId = mail.getHeader("Thread-Index")
        if (topicId!=null) {topicId = MimeUtility.decodeText(topicId[0])} else {topicId=""}
        topicId = cropId(topicId)
        if (topicId != null &amp;&amp; topicId != '' &amp;&amp; topicId.length()&gt;=30) { topicId = topicId[0..29] }
        m.topicId = topicId

        def messageId = mail.getHeader("Message-ID")
        if (messageId!=null) {messageId=MimeUtility.decodeText(messageId[0])} else {messageId=""}
        messageId = cropId(messageId)
        m.messageId = messageId

        def replyToId = mail.getHeader("In-Reply-To")
        if (replyToId !=null) {replyToId =replyToId [0]} else {replyToId =""}
        replyToId = cropId(replyToId)
        m.replyToId = replyToId

        def refs = mail.getHeader("References")
        if (refs!=null) {refs=refs[0]} else {refs=""}
        m.refs = refs

        def subject = mail.getHeader("Subject")
        if (subject != null &amp;&amp; !subject[0].isEmpty()) 
        {
            subject = MimeUtility.decodeText(subject[0]).replaceAll('\n',' ').replaceAll('\r',' ').replaceAll('&gt;', '&amp;gt;').replaceAll('&lt;', '&amp;lt;') 
        } else 
        {
            subject=""
        }
        m.subject = subject

        def topic = mail.getHeader("Thread-Topic")
        if (topic!=null &amp;&amp; !topic[0].isEmpty()) 
        {
            topic = MimeUtility.decodeText(topic[0]).replaceAll('\n',' ').replaceAll('\r',' ')
        } else 
        {
            topic="[no subject]"
            m.subject += topic
        }
        m.topic = topic
  
        def from = mail.getHeader("From")
        if (from!=null) {from = MimeUtility.decodeText(from[0])} else {from=""}
        from = from.replaceAll("\"", "")
        m.from = from

        def to = mail.getHeader("To")
        if (to!=null) {to = MimeUtility.decodeText(to[0])} else {to=""}
        to = to.replaceAll("\"", "")
        m.to = to

        def cc = mail.getHeader("CC")
        if (cc!=null) {cc = MimeUtility.decodeText(cc[0])} else {cc=""}
        cc = cc.replaceAll("\"", "")
        m.cc = cc

        // process the language
        def language = mail.getHeader("Content-Language")
        def locLang = "en"
        def locCountry = "US"
        if (language != null) 
        { 
            language = language[0]
            if (language!= null) 
            {
                def index = language.indexOf('.')
                if (index != -1) 
                {
                    locLang = language.substring(0,index-1)
                    locCountry = language.substring(index)
                }
            }
        }
        Locale locale = new Locale(locLang, locCountry)
        m.locale = locale

        def dateFormatter = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss ZZZZZ", locale)

        def date = mail.getHeader("Date")
        if (date!=null) {date = date[0]} else {date=""}
        // Decode the date
        def decodedDate = dateFormatter.parse(date)
        if (decodedDate == null) { decodedDate = new Date() }
        m.date = date
        m.decodedDate = decodedDate

        //@TODO : not generic part
        def isNewsletter = (subject.toUpperCase().contains("COMMUNITY NEWSLETTER"))
        def isProductRelease = ((from.toUpperCase().contains("DONOTREPLY@GEMALTO.COM") || from.toUpperCase().contains("DOWNLOADZONE")) &amp;&amp; (subject.toUpperCase().startsWith("DELIVERY OF")))
        // end of not generic part
        def type = "Mail"
        //@TODO : not generic part
        if (isNewsletter) { type = "Newsletter" }
        if (isProductRelease) { type = "Product Release" }
        // end of not generic part
        m.type = type
 
        def firstInTopic = (replyToId == "")
        m.isFirstInTopic = firstInTopic
  
        // Try to retrieve wiki user
        def userwiki = parseUser(from)
        if (userwiki ==  null || userwiki == "") {
            userwiki = unknownUser
        }
        m.wikiuser = userwiki

        m.bodypart = mail.getContent()
        m.contentType = mail.getContentType().toLowerCase()

        def sensitivity = mail.getHeader("Sensitivity")
        if (sensitivity == null || sensitivity == "") { 
          sensitivity = "normal";
        }
        m.sensitivity = sensitivity;
        return m
    }

    /**
      * createTopicPage
      * Creates a wiki page for a Topic.
     */
    def createTopicPage (MailItem m, dateFormatter, create) {
 
      def topicDoc

      def topicwikiname = xwiki.clearName("T" + m.topic.replaceAll(" ",""))
      if (topicwikiname.length() &gt;= 30) {
        topicwikiname = topicwikiname.substring(0,30)
      }
      def pagename = xwiki.getUniquePageName("MailArchive", topicwikiname)
      topicDoc = xwiki.getDocument("MailArchive.${pagename}")
      def topicObject = topicDoc.newObject("MailArchiveCode.MailTopicClass")
      topicDoc.use(topicObject)
      topicDoc.set("topicid", m.topicId)
      topicDoc.set("subject", m.topic)
      // Note : we always add author and stardate at topic creation because anyway we will update this later if needed,
      // to avoid topics with "unknown" author
      //if (m.isFirstInTopic)
      //{
        addDebug("adding startdate and author to topic")
        topicDoc.set("startdate", dateFormatter.format(m.decodedDate))
        topicDoc.set("author", m.from)
      //} 
      // when first created, we put the same date as start date
      topicDoc.set("lastupdatedate", dateFormatter.format(m.decodedDate)) 
      topicDoc.document.setCreationDate(m.decodedDate)
      topicDoc.document.setDate(m.decodedDate)
      topicDoc.document.setContentUpdateDate(m.decodedDate)
      topicDoc.set("type", m.type)
      //topicDoc.setContent(xwiki.getDocument("MailArchiveCode.MailTopicClassTemplate").getContent())
      topicDoc.setParent("MailArchive.WebHome")
      topicDoc.setTitle("Topic ${m.topic}")
      topicDoc.setComment("Created topic from mail from folder ${mailingListFolder}")

      // manage mailing list category through tags (card, server, pm...)
      def tag = parseTags(m, threadsMap)
      if (tag != "") { 
        tag = tag + "," 
      }
      tag += m.type
      if (tag != "") {         
        topicDoc.use(topicDoc.newObject("XWiki.TagClass"))
        topicDoc.set("tags", tag.replaceAll(" ", "_") ) 
      }

      if (create) {
        saveAsUser(topicDoc, m.wikiuser, getLoadingUser(), "Created topic from mail from folder ${mailingListFolder}")
      }
      // add the existing topic created to the map
      existingTopics[m.topicId] = [topicDoc.fullName, topicObject.subject]

      return topicDoc
    }

    /**
      * updateTopicPage
      * Update topic against new mail taking part to existing topic.
     */
    def updateTopicPage (MailItem m, existingTopicId, dateFormatter, create) {
       addDebug("updateTopicPage(${existingTopicId})")
 
       def newuser = null
       def topicDoc = xwiki.getDocument(existingTopics[existingTopicId][0])
       addDebug("Existing topic ${topicDoc}")
       def topicObj = topicDoc.getObject("MailArchiveCode.MailTopicClass")
       def lastupdatedate = topicObj.lastupdatedate
       def startdate = topicObj.startdate
       def originalAuthor = topicObj.author
       if (lastupdatedate == null || lastupdatedate == "") { lastupdatedate = m.date } // note : this should never occur
       if (startdate == null || startdate == "") { startdate = m.date }
       def decodedlastupdatedate = dateFormatter.parse(lastupdatedate)
       def decodedstartdate = dateFormatter.parse(startdate)

       def isMoreRecent = (m.decodedDate.getTime() &gt; decodedlastupdatedate.getTime())
       def isMoreAncient = (m.decodedDate.getTime() &lt; decodedstartdate.getTime())
       addDebug("decodedDate = ${m.decodedDate.getTime()}, lastupdatedate = ${decodedlastupdatedate.getTime()}, is more recent = ${isMoreRecent}, first in topic = ${m.isFirstInTopic}")
       addDebug("lastupdatedate $decodedlastupdatedate")
       addDebug("current mail date $m.decodedDate")

       // If the first one, we add the startdate to existing topic
       if (m.isFirstInTopic || isMoreRecent)
       {
         def dirty = false
         addDebug("Checking if existing topic has to be updated ...")
         def comment = ""
//         if (m.isFirstInTopic) {
           if ((originalAuthor != m.from &amp;&amp; isMoreAncient) || originalAuthor == "")
           {
             addDebug("     updating author from ${originalAuthor} to ${m.from}")
             topicDoc.set("author", m.from)
             comment += " Updated author "
             newuser = parseUser(m.from)
             if (newuser ==  null || newuser == "") {
               newuser = unknownUser
             }
             dirty = true
           }
           addDebug("     existing startdate $topicObj.startdate")
           if ((topicObj.startdate == null || topicObj.startdate == "") || isMoreAncient)
           {
             addDebug("     checked startdate not already added to topic")           
             topicDoc.set("startdate", dateFormatter.format(m.decodedDate), topicObj)
             topicDoc.document.setCreationDate(m.decodedDate)
             comment += " Updated start date "
             dirty = true
           }
  //       }
         if (isMoreRecent) {
           addDebug("     updating lastupdatedate from $topicObj.lastupdatedate to " + dateFormatter.format(m.decodedDate))
           topicDoc.set("lastupdatedate", dateFormatter.format(m.decodedDate), topicObj)
           topicDoc.document.setDate(m.decodedDate)
           topicDoc.document.setContentUpdateDate(m.decodedDate)
           newuser = parseUser(m.from)
           comment += " Updated last update date "
           dirty = true
         }
         topicDoc.setComment(comment)

         if (create &amp;&amp; dirty) {
           addDebug("     Updated existing topic")
           saveAsUser(topicDoc, newuser, getLoadingUser(), comment)
         }
         existingTopics[m.topicId] = [topicDoc.fullName, topicObj.subject]
       } else 
       {
         addDebug("     Nothing to update in topic")
       }

      return topicDoc
    }

    /**
      * createMailPage
      * Creates a wiki page for a Mail.
     */
    def createMailPage (MailItem m, existingTopicId, isAttachedMail, parentMail, create) {
        def msgDoc
        def content = ""
        def htmlcontent = ""
        def zippedhtmlcontent = ""
        def attachedMails = [:]
        // a map to store attachment filename = contentId for replacements in HTML retrieved from mails
        def attachmentsMap = [:]
        def attbodyparts = []

        def prefix = 'M'
        if (isAttachedMail) {
            prefix = 'A'
        } 
        def msgwikiname = xwiki.clearName(prefix + m.topic.replaceAll(" ",""))
        if (msgwikiname.length() &gt;= 30) {
            msgwikiname = msgwikiname.substring(0,30)
        }
        def pagename = xwiki.getUniquePageName("MailArchive", msgwikiname )
        msgDoc = xwiki.getDocument("MailArchive.${pagename}")
        addDebug("NEW MSG msgwikiname=$msgwikiname pagename=$pagename")

        def bodypart = m.bodypart
        addDebug("bodypart class " + bodypart.class)
//        addDebug("mail content type " + m.contentType)
        // Retrieve mail body(ies)
        if (m.contentType.contains("pkcs7-mime")
            || m.contentType.contains("multipart/encrypted")) {
            content = "&lt;&lt;&lt;This e-mail was encrypted. Text Content and attachments of encrypted e-mails are not publshed in Mail Archiver to avoid disclosure of restricted or confidential information.&gt;&gt;&gt;"
            htmlcontent = "&lt;i&gt;&amp;lt;&amp;lt;&amp;lt;This e-mail was encrypted. Text Content and attachments of encrypted e-mails are not publshed in Mail Archiver to avoid disclosure of restricted or confidential information.&amp;gt;&amp;gt;&amp;gt;&lt;/i&gt;"
            attachedMails = []
            m.sensitivity = "encrypted"
        } else if (bodypart instanceof String) 
        {  
            content = MimeUtility.decodeText(bodypart)
    
        } else 
        {
            addDebug("Fetching plain text content ...")
            content = getMailContent(bodypart)
            addDebug("Fetching HTML content ...")
            htmlcontent = getMailContentHtml(bodypart, 0)
            addDebug("Fetching attached mails ...")
            attachedMails = getMailContentAttachedMails(bodypart, msgDoc.fullName)
 
            addDebug("Fetching attachments from mail") 
            def nbatts = getMailAttachments(bodypart, attbodyparts)
            addDebug("FOUND $nbatts attachments to add")
            addDebug("Retrieving contentIds ...")
            fillAttachmentContentIds (attbodyparts, attachmentsMap)
        }

        // Truncate body
        content = truncateStringForBytes(content, 65500, 65500)

        /* Treat HTML parts ... */
        zippedhtmlcontent = treatHtml(msgDoc, htmlcontent, attachmentsMap)

        // Treat lengths
        if (m.messageId.length()&gt;255)       { m.messageId = m.messageId[0..254] }
        if (m.subject.length()&gt;255)         { m.subject= m.subject[0..254] }
        if (existingTopicId.length()&gt;255)   { existingTopicId= existingTopicId[0..254] }
        if (m.topicId.length()&gt;255)         { m.topicId= m.topicId[0..254] }
        if (m.topic.length()&gt;255)           { m.topic= m.topic[0..254] }
        // largestrings : normally 65535, but we don't know the size of the largestring itself
        if (m.replyToId.length()&gt;65500)     { m.replyToId= m.replyToId[0..65499] }
        if (m.refs.length()&gt;65500)          { m.refs= m.refs[0..65499] }
        if (m.from.length()&gt;65500)          { m.from= m.from[0..65499] }
        if (m.to.length()&gt;65500)            { m.to= m.to[0..65499] }
        if (m.cc.length()&gt;65500)            { m.cc= m.cc[0..65499] }

        if ((content == null || content == "") &amp;&amp; (htmlcontent != null &amp;&amp; htmlcontent != "")) {
          def converted = null
          try {
            def xdom = services.rendering.parse(htmlcontent, "html/4.01")
            converted = services.rendering.render(xdom, "plain/1.0")
          } catch (Throwable t) {
            addDebug("Conversion from HTML to plain text thrown exception ${t}")
            t.printStackTrace()
            converted = null
          }
          if (converted != null &amp;&amp; converted != "") {
            // replace content with value (remove excessive whitespace also)
            content = converted.replaceAll(~/[\s]{2,}/, "\n")
            addDebug("Text body now contains converted html content")
          } else {
            addDebug("Conversion from HTML to Plain Text returned empty or null string")
          }
        }

        // Fill all new object's fields
        def msgObj = msgDoc.newObject("MailArchiveCode.MailClass")
        msgObj.set("messageid", m.messageId)
        msgObj.set("messagesubject", m.subject)

        msgObj.set("topicid", existingTopicId)  
        msgObj.set("topicsubject", m.topic)      
        msgObj.set("inreplyto", m.replyToId)
        msgObj.set("references", m.refs)
        msgObj.set("date", m.decodedDate)
        msgDoc.document.setCreationDate(m.decodedDate)
        msgDoc.document.setDate(m.decodedDate)
        msgDoc.document.setContentUpdateDate(m.decodedDate)
        msgObj.set("from", m.from)
        msgObj.set("to", m.to)
        msgObj.set("cc", m.cc)
        msgObj.set("body", content)
        msgObj.set("bodyhtml", zippedhtmlcontent)
        msgObj.set("sensitivity", m.sensitivity)
        if (attachedMails.size() != 0) {
            msgObj.set("attachedMails", attachedMails.grep(~/^MailArchive\..*$/).join(','))
        }
        if (!isAttachedMail) {
            if (m.isFirstInTopic) 
            {
                msgObj.set("type", m.type)
            } else
            {
                msgObj.set("type", "Mail")
            }
        } else {
            msgObj.set("type", "Attached Mail")
        }
        if (parentMail != null) {
            msgDoc.setParent(parentMail)
        } else if (existingTopics[m.topicId] != null) {
            msgDoc.setParent(existingTopics[m.topicId][0])
        }
        //msgDoc.setContent(xwiki.getDocument("MailArchiveCode.MailClassTemplate").getContent())
        msgDoc.setTitle("Message ${m.subject}")
        if (!isAttachedMail) {
            msgDoc.setComment("Created message from mailing-list from folder ${mailingListFolder}")
        } else {
            msgDoc.setComment("Attached mail created")
        }
        def tag = parseTags(m, threadsMap)
        if (tag != "") 
        { 
            msgDoc.use(msgDoc.newObject("XWiki.TagClass"))
            msgDoc.set("tags", tag.replaceAll(" ", "_") )
        }

        if (create &amp;&amp; !checkMsgIdExistence(m.messageId)) {
            addDebug("saving message ${m.subject}")
            saveAsUser(msgDoc, m.wikiuser, getLoadingUser(), "Created message from mailing-list from folder ${mailingListFolder}")
        }
        existingMessages[m.messageId] = [m.subject, existingTopicId, msgDoc.fullName]
        addDebug("  mail loaded and saved with id $m.messageId, subject=$m.subject topicid=$m.topicId topicsubject=$m.topic replyto=$m.replyToId references=$m.refs date=$m.decodedDate from=$m.from")

        addDebug("adding attachments to document")
        addAttachmentsFromMail(msgDoc, attbodyparts, attachmentsMap, context)

        return msgDoc

    }

    def parseTags(MailItem m, threadsMap) {
      def tag = ""
      threadsMap.each { thread -&gt;
          if (   m.from.contains(thread.key)
              || m.to.contains(thread.key)
              || m.cc.contains(thread.key) )
          {
             if (tag != "") { tag = tag + "," }
             tag = tag + thread.value[1]
          }
      }
      return tag
    }

    def saveAsUser(doc, user, contentUser, comment) {
        // If user is not provided we leave existing one
        if (user == null) {
          user = doc.document.getCreator()
        }
        // We set creator only at document creation
        if (doc.document.creator == null || doc.document.creator == "") {        
          doc.document.setCreator(user)
        }
        doc.document.setAuthor(user)
        doc.document.setContentAuthor(contentUser)
        doc.document.setContentDirty(false)
        doc.document.setMetaDataDirty(false)
        xwiki.getXWiki().saveDocument(doc.document, comment, this.context.context)
    }


    /* 
    Cleans up HTML content and treat it to replace cid tags with correct image urls (targeting attachments) 
     */
    String treatHtml (msgdoc, htmlcontent, attachmentsMap)
    {
        if (htmlcontent != null &amp;&amp; htmlcontent != "" &amp;&amp; htmlcontent.length() != 0)
        {
            // Try to clean HTML with JTidy to decrease its length and complexity
            addDebug("Original HTML length " + htmlcontent.length())

            // Replace "&amp;nbsp;" to avoid issue of "Â" characters displayed (???)
            htmlcontent = htmlcontent.replaceAll("&amp;Acirc;", " ")

            // Replace attachment URLs in HTML content for images to be shown
            for (att in attachmentsMap) 
            {
                // remove starting "&lt;" and finishing "&gt;"
                def pattern = att.key[1..-2]
                pattern = "cid:${pattern}"
                addDebug("Testing for pattern " + xwiki.getURLEncoded(pattern) + " ${pattern}")
                def replacement = msgdoc.getAttachmentURL(att.value)
                addDebug("To be replaced by ${replacement}")
                htmlcontent = htmlcontent.replaceAll(pattern, replacement)
            }         

            addDebug("Zipping HTML part ...")
            def bos = new ByteArrayOutputStream()
            def zos = new GZIPOutputStream(bos)
            def bytes = htmlcontent.getBytes("UTF8")
            zos.write(bytes, 0, bytes.length)
            zos.finish()
            zos.close()

            def compbytes = bos.toByteArray()
            htmlcontent = byte2hex(compbytes)
            bos.close()

            if (htmlcontent.length() &gt; 65534) 
            {
                addDebug("Failed to have HTML fit in target field")
                htmlcontent = ""
            }

        } else
        {
            addDebug("No HTML to treat")
        }

        addDebug("Html Zipped length : " + htmlcontent.length())
        return htmlcontent
    }


    // Truncate a string "s" to obtain less than a certain number of bytes "maxBytes", starting with "maxChars" characters.
    public String truncateStringForBytes(s, maxChars, maxBytes) {

        def substring = s
        if (s.length() &gt; maxChars) 
        {
            substring = s[0..maxChars]    
        }

        def bytes = substring.getBytes("UTF8")

        if (bytes.length &gt; maxBytes) {

            addDebug("Truncate string to " + substring.length() + " characters, result in " + bytes.length + " bytes array")
            return truncateStringForBytes(s, maxChars - (bytes.length - maxChars)/4, maxBytes)

        } else {

            addDebug("String truncated to " + substring.length() + " characters, resulting in " + bytes.length + " bytes array")
            return substring
        }
 
    }





    /** parseUser
    Parses a user string of the form "user &lt;usermail@com&gt;"
    - extract mail and if matched in xwiki user profiles, returns page name for this profile
    - returns null string if no match is found
    - tries to return profile of a user that's authenticated from LDAP, if any, or else first profile found
     */
    String parseUser (user) {
      def parsedUser = null
      def start = user.indexOf('&lt;')
      def end = user.indexOf('&gt;')
      def mail = ""
      if (start!=-1 &amp;&amp; end != -1) {
        mail = user.substring(start+1, end).toLowerCase()
      }
      if (mail != "") {
        // to match "-external" emails and old mails with '@gemplus.com'...
        mail = mail.toLowerCase()
        mail = mail.replace("-external", "").replaceAll(~/^(.*)@.*[.]com$/, "\$1%@%.com")   
        // Try to find a wiki profile with this email as parameter.
        // TBD : do this in the loading phase, and only try to search db if it was not found ?
        def hql = "select obj.name from BaseObject as obj, StringProperty as prop where obj.className='XWiki.XWikiUsers' and obj.id=prop.id and prop.name='email' and LOWER(prop.value) like '" + mail + "'"

        def wikiuser = xwiki.search(hql)
        if (wikiuser != null &amp;&amp; wikiuser.size() == 0) {
          return null
        } else {
          // If there exists one, we prefer the user that's been authenticated through LDAP
          wikiuser.each() { usr -&gt;
            if (xwiki.getDocument(usr).getObject('XWiki.LDAPProfileClass') != null){
              parsedUser = usr
            }
          }
        }
        if (parsedUser != null) {
          return parsedUser
        } else {
          // If none has authenticated from LDAP, we return the first user found
          return wikiuser[0]
        }
      } else {
        return null;
      }
    }



    void addDebugStackTrace (Exception e) {
        while (e != null) {
            addDebug("CAUSED BY ...")
            e.getStackTrace().each() { 
                addDebug(it.toString())
            }
            e = e.getCause()
        }
    }

    

    // ****** Check existence of wiki object with same value as 'messageid', from database
    public boolean checkMsgIdExistence(msgid) 
    {
        def hql = "select count(*) from StringProperty as prop where prop.name='messageid' and prop.value='${msgid}')"    
        def exists = xwiki.search(hql)
  
        if (exists != null) { addDebug("Class of retrieve msg id count : " + exists + " " + exists[0].class) }

        if (exists == null || exists.size() == 0 || exists[0] == "" || exists[0] == 0 || exists[0] == "0")
        {
            addDebug("Message with ids ${msgid} does not exist in database = " + exists[0])
            return false
        } else
        {
            addDebug("Message with ids ${msgid} already loaded in database = " + exists[0])
            return true
        }

    }




    /* Returns the topicId of already existing topic for this topic id or subject.
    If no topic with this id or subject is found, try to search for a message
    for wich msgid = replyid of new msg, then attach this new msg to the same topic.
    If there is no existing topic, returns null.
    Search topic with same subject only if inreplyto is not empty, meaning it's not supposed
    to be the first message of another topic. */
    public String existsTopic(topicId, topicSubject, inreplyto)
    {
        def foundTopicId = null
        def replyId = inreplyto
        def previous = ""     
        def previousSubject = topicSubject
        def quit = false
 
        // Search in existing messages for existing msg id = new reply id, and grab topic id 
        // search replies until root message
        while (existingMessages.containsKey(replyId) &amp;&amp; existingMessages[replyId] != null &amp;&amp; !quit) 
        {
            def msgDoc = xwiki.getDocument(existingMessages[replyId][2])
            if (msgDoc != null) 
            { 
                def msgObj = msgDoc.getObject("MailArchiveCode.MailClass")
                if (msgObj != null)  
                {
                   addDebug("existsTopic : message ${replyId} is a reply to ${existingMessages[replyId]}")
                   if (similarSubjects(previousSubject,msgObj.topicsubject)) {            
                     previous = replyId
                     replyId = msgObj.inreplyto
                     previousSubject = msgObj.topicSubject
                   } else {
                     addDebug("existsTopic : existing message subject is too different, exiting loop")
                     quit = true
                   }
                } else { replyId = null }
            } else { replyId = null }
        } 
        if (replyId != inreplyto &amp;&amp; replyId != null)
        {
            addDebug("existsTopic : found existing message that current message is a reply to, to attach to same topic id")
            foundTopicId = existingMessages[previous][1]
            addDebug("existsTopic : Found topic id ${foundTopicId}")
        } else
        {
            // Search in existing topics with id
            if (existingTopics.containsKey(topicId))
            {
                addDebug("existsTopic : found topic id in loaded topics")
                if (similarSubjects(topicSubject, existingTopics[topicId][1])) {
                  foundTopicId = topicId
                } else {
                  addDebug("... but subjects are too different")
                }
            } 
            if (foundTopicId == null) 
            {
                // Search in existing topics with exactly same subject
                existingTopics.findAll{it.value[1].trim().equalsIgnoreCase(topicSubject.trim())}.each() {
                  addDebug("existsTopic : found subject in loaded topics")
                  if (inreplyto != "")
                  {           
                    foundTopicId = it.key
                  } else { 
                    addDebug("existsTopic : found a topic but it's first message in topic") 
                    // Note : desperate tentative to attach this message to an existing topic 
                    //        instead of creating a new one ... Sometimes replyId and refs can be 
                    //        empty even if this is a reply to something already loaded, in this
                    //        case we just check if topicId was already loaded once, even if not
                    //        the same topic ...
                    if (existingTopics.containsKey(topicId)) {
                      addDebug("existsTopic : ... but we 'saw' this topicId before, so attach to found topicId ${it.key} with same subject")
                      foundTopicId = it.key
                    }
                  }
                }
            }
        }
  
        return foundTopicId
    }

    /** Compare 2 strings for similarity
        Returns true if strings can be considered similar enough
          - s1 and s2 have a levenshtein distance &lt; 25%
          - s1 or s2 begins with s2 or s1 respectively
    **/

    def similarSubjects (s1, s2) {
      addDebug("similarSubjects : comparing [${s1}] and [${s2}]")
      s1 = s1.replaceAll(~/^([Rr][Ee]:|[Ff][Ww]:)(.*)$/, "\$2")
      s2 = s2.replaceAll(~/^([Rr][Ee]:|[Ff][Ww]:)(.*)$/, "\$2")
      if (s1 == s2) {
        addDebug("similarSubjects : subjects are equal")
        return true
      }
      try {
        def d = getLevenshteinDistance(s1, s2)
        addDebug("similarSubjects : Levenshtein distance d=${d}")
        if (d &lt;= 0.25) {
          addDebug("similarSubjects : subjects are considered similar because d &lt;= 0.25")
          return true
        }
      } catch(IllegalArgumentException iaE) {
        return false
      }
      if (s1.startsWith(s2) || s2.startsWith(s1)) {
        addDebug("similarSubjects : subjects are considered similar because one start with the other")
        return true
      }
      return false
    }

def getLevenshteinDistance (String s, String t) {
  if (s == null || t == null) {
    throw new IllegalArgumentException("Strings must not be null");
  }
		
  /*
    The difference between this impl. and the previous is that, rather 
     than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
     we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
     is the 'current working' distance array that maintains the newest distance cost
     counts as we iterate through the characters of String s.  Each time we increment
     the index of String t we are comparing, d is copied to p, the second int[].  Doing so
     allows us to retain the previous cost counts as required by the algorithm (taking 
     the minimum of the cost count to the left, up one, and diagonally up and to the left
     of the current cost count being calculated).  (Note that the arrays aren't really 
     copied anymore, just switched...this is clearly much better than cloning an array 
     or doing a System.arraycopy() each time  through the outer loop.)

     Effectively, the difference between the two implementations is this one does not 
     cause an out of memory condition when calculating the LD over two very large strings.  		
  */		
		
  int n = s.length(); // length of s
  int m = t.length(); // length of t
		
  if (n == 0) {
    return m;
  } else if (m == 0) {
    return n;
  }

  def p = new int[n+1]; //'previous' cost array, horizontally
  def d = new int[n+1]; // cost array, horizontally
  def _d; //placeholder to assist in swapping p and d

  // indexes into strings s and t
  int i; // iterates through s
  int j; // iterates through t

  char t_j; // jth character of t

  int cost; // cost

  for (i = 0; i&lt;=n; i++) {
     p[i] = i;
  }
		
  for (j = 1; j&lt;=m; j++) {
     t_j = t.charAt(j-1);
     d[0] = j;
		
     for (i=1; i&lt;=n; i++) {
        cost = s.charAt(i-1)==t_j ? 0 : 1;
        // minimum of cell to the left+1, to the top+1, diagonally left and up +cost				
        d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);  
     }

     // copy current distance counts to 'previous row' distance counts
     _d = p;
     p = d;
     d = _d;
  } 
		
  // our last action in the above loop was to switch d and p, so p now 
  // actually has the most recent cost counts
  return p[n] / Math.max(s.length(), t.length());
}

    /* MACROS
    cropId()

    Returns minimum Id string.
     */
    public String cropId (id) {
        def start = id.indexOf('&lt;')
        def end = id.indexOf('&gt;')
        if (start != -1 &amp;&amp; end != -1) { 
            return id.substring(start+1, end)
        } else {
            return id
        }
    }
 
    public int addAttachments(doc1, context1) {
        def doc = doc1.document;
        def context = context1.context;
        def xwiki = context.getWiki()
        int nb = 0;
        def fileupload = xwiki.getPlugin("fileupload",context)
        for (fileitem in fileupload.getFileItems(context)) 
        {
            if (!fileitem.isFormField()) 
            {
                def name = fileitem.fieldName
                byte[] data = fileupload.getFileItemData(name, context);
                if ((data!=null)&amp;&amp;(data.length&gt;0)) 
                {
                    String fname = fileupload.getFileName(name, context);
                    int i = fname.lastIndexOf("\\");
                    if (i==-1)
                    {
                        i = fname.lastIndexOf("/");
                    }
                    def filename = fname.substring(i+1);
                    filename = filename.replaceAll("\\+"," ");
                    def attachment = new XWikiAttachment();
                    doc.getAttachmentList().add(attachment);
                    attachment.setContent(data);
                    attachment.setFilename(filename);
                    // TODO: handle Author
                    attachment.setAuthor(context1.user);
                    // Add the attachment to the document
                    attachment.setDoc(doc);
                    doc.saveAttachmentContent(attachment, context);
                    nb++;
                }
            }
        }
        return nb;
    }      

    /*
    Returns a valid name for an attachment from its original name
     */
    public String getAttachmentValidName(afilename) {
        def fname = afilename
        int i = fname.lastIndexOf("\\")
        if (i==-1)
        i = fname.lastIndexOf("/")
        def filename = fname.substring(i+1)
        filename = filename.replaceAll("\\+"," ")
        return filename
    }

    /*
    Add to document (doc1) an attached file (afilename) with its content (adata), and fills a map (adata)
    with relation between contentId (cid) and (afilename)
     */
    public int addAttachmentFromMail(doc1, afilename, adata, context1) {
        def filename = getAttachmentValidName(afilename)
        addDebug("adding attachment: " + filename);

        def doc = doc1.getDocument();
        def context = context1.getContext();
        def xwiki = context.getWiki()
        def attachment = new XWikiAttachment();
        doc.getAttachmentList().add(attachment);
        attachment.setContent(adata);
        attachment.setFilename(filename);
        // TODO: handle Author
        attachment.setAuthor(context1.user);
        // Add the attachment to the document
        attachment.setDoc(doc);
        addDebug("saving attachment: " + filename);
        doc.setComment("Added attachment ${filename}")
        doc.saveAttachmentContent(attachment, context);

        return 1;
    }

    /*
    Add map of attachments (bodyparts) to a document (doc1)
     */
    public int addAttachmentsFromMail(doc1, bodyparts, attachmentsMap, context1) {
        def nb = 0;
        for(bodypart in bodyparts) 
        {
            String fileName = bodypart.getFileName();
            String cid = bodypart.getContentID();
            // replace by correct name if filename was renamed (multiple attachments with same name)
            if (attachmentsMap.containsKey(cid)) {
                fileName = attachmentsMap[cid]
            }
            addDebug("Treating attachment: ${fileName} with contentid ${cid}");
            if (fileName==null)
            {
                fileName = "fichier.doc"
            }
            if (fileName == "oledata.mso" || fileName.endsWith(".wmz") || fileName.endsWith(".emz"))
            {
                addDebug("Not treating Microsoft crap !")
            } else
            {
                String disposition = bodypart.getDisposition();
                String contentType = bodypart.getContentType().toLowerCase();

                addDebug("Treating attachment of type: " + bodypart.getContentType());
  
                def baos =  new ByteArrayOutputStream();
                OutputStream out = new BufferedOutputStream(baos);
                // We can't just use p.writeTo() here because it doesn't
                // decode the attachment. Instead we copy the input stream
                // onto the output stream which does automatically decode
                // Base-64, quoted printable, and a variety of other formats.
                InputStream ins = new BufferedInputStream(bodypart.getInputStream());
                int b = ins.read()
                while (b != -1) 
                {
                    out.write(b);
                    b = ins.read();
                }
                out.flush();
                out.close();
                ins.close();

                addDebug("Treating attachment step 3: " + fileName);

                byte[] data = baos.toByteArray();
                addDebug("Ready to attach attachment: " + fileName);
                nb += addAttachmentFromMail(doc1, fileName, data, context1);
            } // end if
        } // end for all attachments
        return nb;
    }

    /*
    Fills a map with key=contentId, value=filename of attachment
     */
    public void fillAttachmentContentIds (bodyparts, attmap) {
        for(bodypart in bodyparts) {
            String fileName = bodypart.getFileName()
            String cid = bodypart.getContentID()
            if (cid != null &amp;&amp; cid != "") {
                addDebug("fillAttachmentContentIds: Treating attachment: ${fileName} with contentid ${cid}")
                def name = getAttachmentValidName(fileName)
                def nb=1
                if (!name.contains('.')) {
                  name = "${name}.ext"
                }
                def newName = name
                while (attmap.containsValue(newName)) {
                   addDebug("fillAttachmentContentIds: ${newName} attachment already exists, renaming to ${name.replaceAll(~/(.*)\.([^.]*)/, "\$1-${nb}.\$2")}")
                   newName = name.replaceAll(~/(.*)\.([^.]*)/, "\$1-${nb}.\$2")
                   nb++
                }
                attmap[cid] = newName
            } else {
                addDebug("fillAttachmentContentIds: content ID is null, nothing to do")
            }     
        }
    }

    /*
    Retrieves body parts for content from mail, and returns them as a String 
     */
    public String getMailContent(bodypart) {
        String content = ""
        def is
        def str
        try {
            def mcount = bodypart.getCount();
            def i = 0;
            while (i&lt;mcount) {
                def newbodypart = bodypart.getBodyPart(i)
                addDebug("BODYPART CONTENTTYPE = " + newbodypart.getContentType().toLowerCase() + " FILENAME = " + newbodypart.getFileName())
                // We don't treat attachments here
                if (newbodypart.getFileName() != null) {
                  if(newbodypart.getContentType().toLowerCase().contains("vcard")) {
                      addDebug("Adding vcard to content");
                      if (!content.toLowerCase().contains("xwiki"))
                      {
                          str = newbodypart.getContent()
                          content = "${content} ${str}"
                      }
                  }
                  // Note : we treat HTML or XML appart
                  else if(   newbodypart.getContentType().toLowerCase().startsWith("text/")
                      &amp;&amp; !(newbodypart.getContentType().toLowerCase().startsWith("text/html"))
                      &amp;&amp; !(newbodypart.getContentType().toLowerCase().startsWith("text/xml"))) 
                  {
                      addDebug("Adding text to content");
                      str = newbodypart.getContent()
                      content = "${content} ${str}"
                  }


                  if(newbodypart.getContentType().toLowerCase().startsWith("multipart/")) {
                      addDebug("Adding multipart to content");
                      def ncontent = getMailContent(newbodypart.content)
                      if (ncontent!="") 
                      content = "${content} ${ncontent}"
                  }

                  if (newbodypart.getContentType().toLowerCase().startsWith("message/rfc822")) {
                      addDebug("Adding rfc822 to content");
                      def ncontent = getMailContent(newbodypart.content.content)
                      if (ncontent!="") 
                      content = "${content} ${ncontent}"  
                  }
                } // not an attachment
     
                i++;
            }

            return content;
        } catch (Exception e) {
            addDebug("Failed to get Mail Content " + e.class + " " + e.getMessage());
            e.printStackTrace();
            return "Failed to get Mail Content";
        }
    }    

    /* 
    Retrieves HTML parts only from a mail and returns them as String 
     */
    public String getMailContentHtml(bodypart, level) {
        String content = ""
        try {
            def mcount = bodypart.getCount();
            def i = 0;
            while (i&lt;mcount) {
                def newbodypart = bodypart.getBodyPart(i)
                addDebug(("\t" * level) + "BODYPART CONTENTTYPE = " + newbodypart.getContentType().toLowerCase() + " FILENAME = " + newbodypart.getFileName())
                // we don't treat attachments here
                if (newbodypart.getFileName() == null) {
                  // Note : we treat HTML appart
                  if(newbodypart.getContentType().toLowerCase().startsWith("text/html")) 
                  {
                      addDebug("Adding HTML text of length "+newbodypart.content.length()+" to content");
                      def htmlcontent = newbodypart.getContent();
                      content = "${content} ${htmlcontent}"
                  }

                  if(newbodypart.getContentType().toLowerCase().startsWith("multipart/")) {
                      addDebug("Adding multipart to content");
                      def ncontent = getMailContentHtml(newbodypart.content, level+1)
                      if (ncontent!="") 
                      content = "${content} ${ncontent}"
                  }

                  if (newbodypart.getContentType().toLowerCase().startsWith("message/rfc822")) {
                      addDebug("Adding rfc822 to content");
                      addDebug(("\t" * level) + "BODYPART CONTENTTYPE for RFC822 = " + newbodypart.content.getContentType().toLowerCase() + " FILENAME = " + newbodypart.content.getFileName())
                      def from = newbodypart.content.getHeader("From")
                      // If header is set, it's likely to be an attached mail to the original mail, so we load it first
                      if (from != null &amp;&amp; from != "") {
                          addDebug("Not Html, but attached email")
                      } else {
                          def ncontent = getMailContentHtml(newbodypart.content.content, level+1)
                          if (ncontent!="") 
                          content = "${content} ${ncontent}"  
                      }
                  }
                } else { // not an attachment
                   addDebug("bodypart has a filename ${newbodypart.getFileName()}, no html to fetch")
                }
     
                i++;
            }

            return content;

        } catch (Exception e) {
            addDebug("Failed to get Html Mail Content " + e.class + " "+ e.getMessage());
            e.printStackTrace();
            return "Failed to get Html Mail Content " + e.class + " " + e.getMessage();
        }
    }   

    /* 
    Retrieves attached mails parts only from a mail, loads them and returns a String with list of created pages
     */
    public String[] getMailContentAttachedMails(bodypart, parentMail) {
        try {
            def attachedMailsList = []
            def mcount = bodypart.getCount();
            def i = 0;
            def result
            while (i&lt;mcount) {
                def newbodypart = bodypart.getBodyPart(i)

                if(newbodypart.getContentType().toLowerCase().startsWith("multipart/")) {
                    addDebug("Adding multipart to attached mails");
                    result = getMailContentAttachedMails(newbodypart.content, parentMail)
                    attachedMailsList += result
                }

                if (newbodypart.getContentType().toLowerCase().startsWith("message/rfc822")) {
                    addDebug("Adding rfc822 to content");
                    addDebug("BODYPART CONTENTTYPE for RFC822 = " + newbodypart.content.getContentType().toLowerCase() + " FILENAME = " + newbodypart.content.getFileName())
                    def from = newbodypart.content.getHeader("From")
                    // If header is set, it's likely to be an attached mail to the original mail, so we load it first
                    if (from != null &amp;&amp; from != "") {
                        result = loadMail(newbodypart.content, true, true, parentMail)
                        if (result[0] &amp;&amp; result[2] != null) {
                            attachedMailsList += result[2] // result[2] is the name of created page for this attached mail
                        }
                    } else {
                        result = getMailcontentAttachedMails(newbodypart.content.content, parentMail)
                        attachedMailsList += result
                    }
                }
     
                i++;
            }

            return attachedMailsList;

        } catch (Exception e) {
            addDebug("Failed to get Attached Mails Content " + e.class + " "+ e.getMessage());
            e.printStackTrace();
            return "Failed to get Attached Mails Content " + e.class + " " + e.getMessage();
        }
    } 
 

    public String inputStreamToString(final InputStream stream) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(stream));
        StringBuilder sb = new StringBuilder();
        String line = null;
        while ((line = br.readLine()) != null) {
            sb.append(line + "\n");
        }
        br.close();
        return sb.toString();
    }
  
    public String htmlEncode(html)
    {
        def result = ""

   

        return result
    }


    /* 
    Fills a map (bodyparts) with attachments found recursively in mail (bodypart) 
     */
    public int getMailAttachments(bodypart, bodyparts) {
        def nb = 0;
        try {
            def mcount = bodypart.getCount();
            def i = 0;
            while (i&lt;mcount) {     
                def newbodypart = bodypart.getBodyPart(i)

                if (newbodypart.getFileName() != null) {
                  nb++;
                  bodyparts.add(newbodypart)
                  addDebug("getMailAttachments: found an attachment " + newbodypart.getFileName())
                } else if(   newbodypart.getContentType().toLowerCase().startsWith("application/")
                      || newbodypart.getContentType().toLowerCase().startsWith("image/")) {
                  nb++;
                  bodyparts.add(newbodypart)
                  addDebug("getMailAttachments: found an attachment " + newbodypart.class)
                }               
    
                if(newbodypart.getContentType().toLowerCase().startsWith("multipart/")) {
                    nb += getMailAttachments(newbodypart.content,bodyparts)
                }

                if(newbodypart.getContentType().toLowerCase().startsWith("message/rfc822")) {
                    nb += getMailAttachments(newbodypart.content.content,bodyparts)
                }
      
                i++;
            }   

        } catch (Exception e) {
            addDebug("Failed to retrieve mail attachments : " + e.class + " " + e.getMessage())
            e.printStackTrace()
            nb = 0;
        }

        return nb;
    }      

    public Object getMailAddress(message, bodypart) {
        def address = (message==null) ? "" : message.getFrom()[0];
        addDebug("Found address: " + address);
        try {
            def mcount = bodypart.getCount();
            addDebug("Found body parts: " + mcount);
            def i = 0;
            while (i&lt;mcount) {
                def newbodypart = bodypart.getBodyPart(i)

                addDebug("Checking body part " + i + " " + newbodypart.getContentType().toLowerCase());

                if(newbodypart.getContentType().toLowerCase().startsWith("multipart/")) {
                    def add = getMailAddress(null, newbodypart.content)
                    addDebug("Found address in multipart: " + add);
                    if ((add!=null)&amp;&amp;(add!="")) 
                    address = add;
                }

                if (newbodypart.getContentType().toLowerCase().startsWith("message/rfc822")) {
                    def add = getMailAddress(newbodypart.content, newbodypart.content.content)
                    addDebug("Found address in rfc822: " + add);
                    if ((add!=null)&amp;&amp;(add!="")) 
                    address = add;
                }
     
                i++;
            }
            return address;
        } catch (Exception e) {
            return address;
        }
    }   

    public Map readMail(content) {
        def map = new HashMap();
        def lines = content.split("\n")
        for (line in lines) {
            def i = line.indexOf("=");
            if (i!=-1) {
                def key = line.substring(0, i).trim();
                def value = line.substring(i+1).trim();
                if (mapping.get(key))
                key = mapping.get(key);
                map.put(key, value);
                addDebug("KEY [" + key + "] VALUE [" + value + "]")
            }
        }
        return map;
    }

    public lock () 
    {
        // We authorize only one execution at a time
        def appContext = this.request.getSession().getServletContext()
        def isLoading = appContext.getAttribute("com.gemalto.gse.wiki.mailarchiver.Locked")  
        def lockDate = appContext.getAttribute("com.gemalto.gse.wiki.mailarchiver.LockDate")
        addDebug("Trying to get lock ... Already locked ? ${isLoading}")

        if (isLoading == null) 
        { 
            isLoading = "false" 
        }
        if (isLoading.equalsIgnoreCase("true")) 
        {
            def reached = new Date().getTime()-2*60*60*1000
            addDebug("Lock date ${lockDate} compared to now minus delay ${reached} still have to wait for " + (lockDate-reached)/1000/60/60 + " hour(s) for lock to be released or process to end")
            // Did lock time-out ?
            if (lockDate != null &amp;&amp; lockDate &lt; reached)
            {
                addDebug("Lock timed out")
                addDebug("Releasing existing lock")
                release()
            } else {
                addDebug("Mail loader already loading mails - nothing to do")
                return false
            }
        } 

        addDebug("Mail loader not already in progress - loading new mails")
        appContext.setAttribute("com.gemalto.gse.wiki.mailarchiver.Locked", "true")    
        appContext.setAttribute("com.gemalto.gse.wiki.mailarchiver.LockDate", new Date().getTime())

        addDebug("Lock acquired")
        return true
    }

    public release ()
    {
        def appContext = this.request.getSession().getServletContext()
        appContext.setAttribute("com.gemalto.gse.wiki.mailarchiver.Locked", "false")    
        appContext.removeAttribute("com.gemalto.gse.wiki.mailarchiver.LockDate")
        addDebug("Lock released")
    }




    private byte charToByte(char c){
        return (byte) "0123456789ABCDEF".indexOf(c);
    }

    /**
     * BD : Used to transfer hex string into byte array. two hex string combines one byte. So that means the length of hex string
     *      should be even. Or the null will be returned.
     * @param hexStr
     * @return
     */
    public byte[] hex2byte(String hexStr) {
        if(hexStr == null || hexStr.isEmpty() || (hexStr.length()%2&gt;1)) {
            return null;
        }
        String hexStrUp = hexStr.toUpperCase();
        int length = hexStrUp.length()/2;
        char[] hexChars = hexStrUp.toCharArray();
        byte[] resultByte = new byte[length];
        for(int i=0;i&lt;length;i++) {
            int pos = i*2;
            resultByte[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos+1]));            
        }
        return resultByte;
    }

    /**
     * BD : Used to transfer byte array into hex string.
     * @param b
     * @return
     */
    public String byte2hex(byte[] b){
        StringBuffer hexStr= new StringBuffer("");
        String stmp = "";
        for(int i=0;i&lt;b.length;i++) {
            stmp = (java.lang.Integer.toHexString(b[i] &amp; 0xFF));
            if(stmp.length() == 1) {
                hexStr.append("0"+stmp);
            } else {
                hexStr.append(stmp);
            }            
        }
        return hexStr.toString().toUpperCase();
    }




    public class MailItem {

        def date
        def subject
        def topic
        def from
        def to
        def cc
        def topicId
        def messageId
        def replyToId
        def refs
        def locale
        def bodypart
        def contentType
        def sensitivity
        def decodedDate
        def type
        def wikiuser
        def isFirstInTopic

        public MailItem() {
        }

        public String toString() {
            def StringBuilder result = new StringBuilder()

            result.append("MailItem [\n")
            .append("\t  date:'").append(date).append("'\n")
            .append("\t, subject:'").append(subject).append("'\n")
            .append("\t, topic:'").append(topic).append("'\n")
            .append("\t, from:'").append(from).append("'\n")
            .append("\t, to:'").append(to).append("'\n")
            .append("\t, cc:'").append(cc).append("'\n")
            .append("\t, topicId:'").append(topicId).append("'\n")
            .append("\t, messageId:'").append(messageId).append("'\n")
            .append("\t, replyToId:'").append(replyToId).append("'\n")
            .append("\t, refs:'").append(refs).append("'\n")
            .append("\t, contentType:'").append(contentType).append("'\n")
            .append("\t, sensitivity:'").append(sensitivity).append("'\n")
            .append("\t, locale:'").append(locale).append("'\n")
            .append("\t, type:'").append(type).append("'\n")
            .append("\t, wikiuser:'").append(wikiuser).append("'\n")
            .append("\t, isFirstInTopic:'").append(isFirstInTopic).append("'\n")
            .append("]")
        }     

    }


}


</content></xwikidoc>